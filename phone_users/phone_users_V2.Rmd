---
title: "PhoneUsers"
author: "Group D"
date: "2024-04-10"
output: html_document
---

```{r include=FALSE}
# Clear workspace, install library & import data
library("caret")
library("Metrics")
library("corrplot")
library("earth")
library("tree")

set.seed(1234)
```

```{r include=FALSE}
rm(list = ls())
train <- read.csv("phone_train.csv", header=TRUE)
test <- read.csv("phone_validation.csv", header=TRUE)

train$sex <- as.factor(train$sex)
train$payment.method <- as.factor(train$payment.method)
train$activation.zone <- as.factor(train$activation.zone)
train$activation.channel <- as.factor(ifelse(train$activation.channel==5, 1, 0)) #Merge
train$tariff.plan <- as.factor(ifelse(train$tariff.plan <= 6, 1, train$tariff.plan)) #Merge
train$vas1 <- as.factor(train$vas1)
train$vas2 <- as.factor(train$vas2)

test$sex <- as.factor(test$sex)
test$payment.method <- as.factor(test$payment.method)
test$activation.zone <- as.factor(ifelse(test$activation.zone == 0, 1, test$activation.zone))
test$activation.channel <- as.factor(ifelse(test$activation.channel==5, 1, 0)) #Merge
test$tariff.plan <- as.factor(ifelse(test$tariff.plan <= 6, 1, test$tariff.plan)) #Merge
test$vas1 <- as.factor(test$vas1)
test$vas2 <- as.factor(test$vas2)

# Convert all the numeric features to log(X+1)
q09 <- c("q09.in.dur.tot", "q09.in.ch.tot", "q09.out.val.peak", "q09.out.dur.peak", "q09.out.ch.peak")
q08 <- c("q08.in.dur.tot", "q08.in.ch.tot", "q08.out.val.peak", "q08.out.dur.peak", "q08.out.ch.peak")
q07 <- c("q07.in.dur.tot", "q07.in.ch.tot", "q07.out.val.peak", "q07.out.dur.peak", "q07.out.ch.peak")
other <- c("age", "sex", "payment.method", "activation.zone", "activation.channel", "tariff.plan", "vas1", "vas2")
```


Random forest: prediction if the user has a positive duration of calls
```{r}
rfDf <- train
# Create a new binary response variable. 1 if the customer has more than 0 minutes of outgoing calls, 0 otherwise
rfDf$y_binary <- factor(ifelse(train$y > 0, 1, 0), levels = c(0, 1))
# Remove y to avoid using it as a predictor
rfDf$y <- NULL

# Create a new data frame with the last three months of data (feature starting with q09, q08, q07)


#rfDfLastThreeMonths <- rfDf[, c(q09, q08, q07, other, "y_binary")]
rfDfLastTwoMonths <- rfDf[, c(q09, q08, other, "y_binary")]

# Fit a random forest model
rfFit <- caret::train(y_binary ~ ., data = rfDfLastTwoMonths, method = "rf", trControl = trainControl(method = "cv", number = 10), preProcess = c("center", "scale"), mttry = 30)

# Get accuracy
accuracy <- max(rfFit$results$Accuracy)
accuracy

```

```{r}
#logiDf <- train
# Create a new binary response variable. 1 if the customer has more than 0 minutes of outgoing calls, 0 otherwise
#logiDf$y_binary <- factor(ifelse(train$y > 0, 1, 0), levels = c(0, 1))
# Remove y to avoid using it as a predictor
#logiDf$y <- NULL
#logiDfLastTwoMonths <- logiDf[, c(q09, q08, other, "y_binary")]
# Train a logistic regression model
# Since the binary response depends only on the actual call traffic, we remove the other variables that are not related to the call traffic 

#logi_model <- glm(y_binary ~ ., data = logiDfLastTwoMonths, family = "binomial")
#logi_model <- caret::train(y_binary ~ ., data = logiDfLastTwoMonths, method = "regLogistic", trControl = trainControl(method = "cv", number = 10), preProcess = c("center", "scale"))

```


```{r}
# Scatterplot of positive call duration
posDf <- train[train$y > 0, ]
posDf$y_binary <- NULL

posDf$tariff.plan <- as.numeric(posDf$tariff.plan)
posDf$activation.channel <- as.numeric(posDf$activation.channel)
posDf$activation.zone <- as.numeric(posDf$activation.zone)
posDf$payment.method <- as.numeric(posDf$payment.method)
posDf$sex <- as.numeric(posDf$sex)
posDf$vas1 <- as.numeric(posDf$vas1)
posDf$vas2 <- as.numeric(posDf$vas2)


correlationMatrix <- cor(posDf)
correlationMatrixY <- correlationMatrix["y", ]
correlationMatrixY <- correlationMatrixY[order(abs(correlationMatrixY), decreasing = TRUE)]
barplot(correlationMatrixY, las = 2, cex.names = 0.7, main = "Correlation of features with y")


```


Train a model on samples with the response different from 0 (MARS)
```{r}
# Create a new data frame with all 
#marsDf <- train[train$y > 0, ]
marsDf <- train
marsDf$y_binary <- NULL

marsDfLastTwoMonths <- marsDf[, c(q09, q08, other, "y")]

# Train a MARS model with bagEarthGCV using Caret
# Grid search for the best degree
mars_model <- caret::train(log(y+1) ~ ., data = marsDfLastTwoMonths, method = "gcvEarth", trControl = trainControl(method = "cv", number = 10), tuneGrid = data.frame(degree = 1:5), preProcess = c("center", "scale"))

summary(mars_model)
# Visualize the MARS model
plot(mars_model)

# Get the best model
best_mars_model <- mars_model$finalModel
```

Train a model on samples with the response different from 0 (LINEAR)
```{r}
# Create a new data frame with all 
#lmDf <- train[train$y > 0, ]
#lmDf$y_binary <- NULL

#baseModel <- lm(y ~ 1, data = lmDf)
#FwStepSel <- step(baseModel, direction = "forward", scope = list(lower = baseModel, upper = lm(y ~ ., data = lmDf)), trace = 0)
#FwStepSel$call$formula

#Based on the previous step results:
#lm_model = train(FwStepSel$call$formula, data = lmDf, trControl = trainControl(method = "loocv", number = 10), preProcess = c("center", "scale"))
#summary(lm_model)
```


Train a model on samples with the response different from 0
```{r}
combinedModel <- function(test, classModel, regModel) {
  # Predict outcomes using the random forest model for the entire test set
  y_rf = predict(classModel, newdata = test, type = "prob")
  tresh = 0.25
  y_rf = ifelse(y_rf[, 2] > tresh, 1, 0)
  
  
  # Initialize yhat with zeros
  yhat = rep(0, nrow(test))
  
  # Identify the rows where the prediction outcome is non-zero
  non_zero_indices = which(y_rf != 0)
  
  # Apply the regression model only to the rows with non-zero outcomes
  if(length(non_zero_indices) > 0) {
    yhat[non_zero_indices] = exp(predict(regModel, newdata = test[non_zero_indices, ]))-1
  }
  
  return(yhat)
}

# Predict all values of test set
yhat <- combinedModel(test, rfFit, mars_model)

# Write the results to a file
write.table(file="mySubmission.txt", pmax(0, yhat), row.names = FALSE, col.names = FALSE)
```




